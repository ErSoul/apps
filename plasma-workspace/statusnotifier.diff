From: David Edmundson <david@davidedmundson.co.uk>
Date: Mon, 29 Feb 2016 11:08:24 +0000
Subject: Avoid blocking DBus calls in SNI startup
X-Git-Url: http://quickgit.kde.org/?p=plasma-workspace.git&a=commitdiff&h=49440a7ce0623d1bc8aca459eaed35612d384cfd
---
Avoid blocking DBus calls in SNI startup

All autogenerated qtdbus property fetches are synchronous and not ideal
for Plasma to call.

Don't bother checking the protocol version.
If the signals are the same, we may as well try and use the old signals,
if it's not - the signals won't match anything anyway so it won't do
anything anyway.

Replace the blocking RegisteredStatusNotifierItem request with an
async variant.

CCBUG: 359611
REVIEW: 127199
---


--- a/dataengines/statusnotifieritem/CMakeLists.txt
+++ b/dataengines/statusnotifieritem/CMakeLists.txt
@@ -17,6 +17,7 @@
 
 set(statusnotifierwatcher_xml ${KNOTIFICATIONS_DBUS_INTERFACES_DIR}/kf5_org.kde.StatusNotifierWatcher.xml)
 qt5_add_dbus_interface(statusnotifieritem_engine_SRCS ${statusnotifierwatcher_xml} statusnotifierwatcher_interface)
+qt5_add_dbus_interface(statusnotifieritem_engine_SRCS ../mpris2/org.freedesktop.DBus.Properties.xml dbusproperties)
 
 set(statusnotifieritem_xml ${KNOTIFICATIONS_DBUS_INTERFACES_DIR}/kf5_org.kde.StatusNotifierItem.xml)
 

--- a/dataengines/statusnotifieritem/statusnotifieritem_engine.cpp
+++ b/dataengines/statusnotifieritem/statusnotifieritem_engine.cpp
@@ -20,7 +20,10 @@
  ***************************************************************************/
 
 #include "statusnotifieritem_engine.h"
+#include <QStringList>
 #include "statusnotifieritemsource.h"
+
+#include "dbusproperties.h"
 
 #include <QDebug>
 #include <iostream>
@@ -89,17 +92,26 @@
 
         m_statusNotifierWatcher = new org::kde::StatusNotifierWatcher(s_watcherServiceName, QStringLiteral("/StatusNotifierWatcher"),
 								      QDBusConnection::sessionBus());
-        if (m_statusNotifierWatcher->isValid() &&
-            m_statusNotifierWatcher->property("ProtocolVersion").toBool() == s_protocolVersion) {
+        if (m_statusNotifierWatcher->isValid()) {
+            m_statusNotifierWatcher->call(QDBus::NoBlock, QStringLiteral("RegisterStatusNotifierHost"), m_serviceName);
+
+            OrgFreedesktopDBusPropertiesInterface  propetriesIface(m_statusNotifierWatcher->service(), m_statusNotifierWatcher->path(), m_statusNotifierWatcher->connection());
+
+            QDBusPendingReply<QDBusVariant> pendingItems = propetriesIface.Get(m_statusNotifierWatcher->interface(), "RegisteredStatusNotifierItems");
+
+            QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(pendingItems, this);
+            connect(watcher, &QDBusPendingCallWatcher::finished, this, [=]() {
+                watcher->deleteLater();
+                QDBusReply<QDBusVariant> reply = *watcher;
+                QStringList registeredItems = reply.value().variant().toStringList();
+                foreach (const QString &service, registeredItems) {
+                    newItem(service);
+                }
+            });
+
             connect(m_statusNotifierWatcher, &OrgKdeStatusNotifierWatcherInterface::StatusNotifierItemRegistered, this, &StatusNotifierItemEngine::serviceRegistered);
             connect(m_statusNotifierWatcher, &OrgKdeStatusNotifierWatcherInterface::StatusNotifierItemUnregistered, this, &StatusNotifierItemEngine::serviceUnregistered);
 
-            m_statusNotifierWatcher->call(QDBus::NoBlock, QStringLiteral("RegisterStatusNotifierHost"), m_serviceName);
-
-            QStringList registeredItems = m_statusNotifierWatcher->property("RegisteredStatusNotifierItems").value<QStringList>();
-            foreach (const QString &service, registeredItems) {
-                newItem(service);
-            }
         } else {
             delete m_statusNotifierWatcher;
             m_statusNotifierWatcher = 0;
