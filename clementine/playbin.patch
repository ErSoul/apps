From 7f917e8e4b635f51cd7a4803aa4665a734dfa44c Mon Sep 17 00:00:00 2001
From: Alexander Bikadorov <abiku@cs.tu-berlin.de>
Date: Tue, 7 Oct 2014 17:47:27 +0200
Subject: [PATCH] Use playbin instead of uridecodebin when possible. Also fixes
 issue 4293

---
 src/engines/gstengine.h           |   2 +-
 src/engines/gstenginepipeline.cpp | 300 +++++++++++++++++---------------------
 src/engines/gstenginepipeline.h   |  32 ++--
 3 files changed, 144 insertions(+), 190 deletions(-)

diff --git a/src/engines/gstengine.h b/src/engines/gstengine.h
index 6c9fa11..ba36beb 100755
--- a/src/engines/gstengine.h
+++ b/src/engines/gstengine.h
@@ -168,7 +168,7 @@ class GstEngine : public Engine::Base, public BufferConsumer {
 
  private:
   static const qint64 kTimerIntervalNanosec = 1000 * kNsecPerMsec;  // 1s
-  static const qint64 kPreloadGapNanosec = 2000 * kNsecPerMsec;     // 2s
+  static const qint64 kPreloadGapNanosec = 3000 * kNsecPerMsec;     // 3s
   static const qint64 kSeekDelayNanosec = 100 * kNsecPerMsec;       // 100msec
 
   static const char* kHypnotoadPipeline;
diff --git a/src/engines/gstenginepipeline.cpp b/src/engines/gstenginepipeline.cpp
index af7e720..bdbd264 100644
--- a/src/engines/gstenginepipeline.cpp
+++ b/src/engines/gstenginepipeline.cpp
@@ -53,9 +53,6 @@ GstEnginePipeline::GstEnginePipeline(GstEngine* engine)
       sink_(GstEngine::kAutoSink),
       segment_start_(0),
       segment_start_received_(false),
-      emit_track_ended_on_stream_start_(false),
-      emit_track_ended_on_time_discontinuity_(false),
-      last_buffer_offset_(0),
       eq_enabled_(false),
       eq_preamp_(0),
       stereo_balance_(0.0f),
@@ -76,10 +73,10 @@ GstEnginePipeline::GstEnginePipeline(GstEngine* engine)
       pipeline_is_initialised_(false),
       pipeline_is_connected_(false),
       pending_seek_nanosec_(-1),
+      next_uri_set_(false),
       volume_percent_(100),
       volume_modifier_(1.0),
       pipeline_(nullptr),
-      uridecodebin_(nullptr),
       audiobin_(nullptr),
       queue_(nullptr),
       audioconvert_(nullptr),
@@ -138,65 +135,48 @@ void GstEnginePipeline::set_mono_playback(bool enabled) {
   mono_playback_ = enabled;
 }
 
-bool GstEnginePipeline::ReplaceDecodeBin(GstElement* new_bin) {
-  if (!new_bin) return false;
+bool GstEnginePipeline::InitDecodeBin(GstElement* decode_bin) {
+  if (!decode_bin) return false;
 
-  // Destroy the old elements if they are set
-  // Note that the caller to this function MUST schedule the old uridecodebin_
-  // for deletion in the main thread.
-  if (uridecodebin_) {
-    gst_bin_remove(GST_BIN(pipeline_), uridecodebin_);
-  }
+  pipeline_ = gst_pipeline_new("pipeline");
+
+  gst_bin_add(GST_BIN(pipeline_), decode_bin);
+
+  if (!InitAudioBin()) return false;
+  gst_bin_add(GST_BIN(pipeline_), audiobin_);
 
-  uridecodebin_ = new_bin;
-  segment_start_ = 0;
-  segment_start_received_ = false;
-  pipeline_is_connected_ = false;
-  gst_bin_add(GST_BIN(pipeline_), uridecodebin_);
+  gst_element_link(decode_bin, audiobin_);
 
   return true;
 }
 
-bool GstEnginePipeline::ReplaceDecodeBin(const QUrl& url) {
-  GstElement* new_bin = nullptr;
-
-  if (url.scheme() == "spotify") {
-    new_bin = gst_bin_new("spotify_bin");
+GstElement* GstEnginePipeline::CreateSpotifyBin(const QUrl& url) {
+  GstElement* new_bin = gst_bin_new("spotify_bin");
 
-    // Create elements
-    GstElement* src = engine_->CreateElement("tcpserversrc", new_bin);
-    GstElement* gdp = engine_->CreateElement("gdpdepay", new_bin);
-    if (!src || !gdp) return false;
+  // Create elements
+  GstElement* src = engine_->CreateElement("tcpserversrc", new_bin);
+  GstElement* gdp = engine_->CreateElement("gdpdepay", new_bin);
+  if (!src || !gdp) return nullptr;
 
-    // Pick a port number
-    const int port = Utilities::PickUnusedPort();
-    g_object_set(G_OBJECT(src), "host", "127.0.0.1", nullptr);
-    g_object_set(G_OBJECT(src), "port", port, nullptr);
+  // Pick a port number
+  const int port = Utilities::PickUnusedPort();
+  g_object_set(G_OBJECT(src), "host", "127.0.0.1", nullptr);
+  g_object_set(G_OBJECT(src), "port", port, nullptr);
 
-    // Link the elements
-    gst_element_link(src, gdp);
+  // Link the elements
+  gst_element_link(src, gdp);
 
-    // Add a ghost pad
-    GstPad* pad = gst_element_get_static_pad(gdp, "src");
-    gst_element_add_pad(GST_ELEMENT(new_bin), gst_ghost_pad_new("src", pad));
-    gst_object_unref(GST_OBJECT(pad));
+  // Add a ghost pad
+  GstPad* pad = gst_element_get_static_pad(gdp, "src");
+  gst_element_add_pad(GST_ELEMENT(new_bin), gst_ghost_pad_new("src", pad));
+  gst_object_unref(GST_OBJECT(pad));
 
-    // Tell spotify to start sending data to us.
-    InternetModel::Service<SpotifyService>()->server()->StartPlaybackLater(
-        url.toString(), port);
-    spotify_offset_ = 0;
-  } else {
-    new_bin = engine_->CreateElement("uridecodebin");
-    g_object_set(G_OBJECT(new_bin), "uri", url.toEncoded().constData(),
-                 nullptr);
-    CHECKED_GCONNECT(G_OBJECT(new_bin), "drained", &SourceDrainedCallback,
-                     this);
-    CHECKED_GCONNECT(G_OBJECT(new_bin), "pad-added", &NewPadCallback, this);
-    CHECKED_GCONNECT(G_OBJECT(new_bin), "notify::source", &SourceSetupCallback,
-                     this);
-  }
+  // Tell spotify to start sending data to us.
+  InternetModel::Service<SpotifyService>()->server()->StartPlaybackLater(
+      url.toString(), port);
+  spotify_offset_ = 0;
 
-  return ReplaceDecodeBin(new_bin);
+  return new_bin;
 }
 
 GstElement* GstEnginePipeline::CreateDecodeBinFromString(const char* pipeline) {
@@ -218,7 +198,7 @@ GstElement* GstEnginePipeline::CreateDecodeBinFromString(const char* pipeline) {
   }
 }
 
-bool GstEnginePipeline::Init() {
+bool GstEnginePipeline::InitAudioBin() {
   // Here we create all the parts of the gstreamer pipeline - from the source
   // to the sink.  The parts of the pipeline are split up into bins:
   //   uri decode bin -> audio bin
@@ -239,7 +219,6 @@ bool GstEnginePipeline::Init() {
 
   // Audio bin
   audiobin_ = gst_bin_new("audiobin");
-  gst_bin_add(GST_BIN(pipeline_), audiobin_);
 
   // Create the sink
   if (!(audiosink_ = engine_->CreateElement(sink_, audiobin_))) return false;
@@ -414,39 +393,17 @@ bool GstEnginePipeline::Init() {
   bus_cb_id_ = gst_bus_add_watch(gst_pipeline_get_bus(GST_PIPELINE(pipeline_)),
                                  BusCallback, this);
 
-  MaybeLinkDecodeToAudio();
-
   return true;
 }
 
-void GstEnginePipeline::MaybeLinkDecodeToAudio() {
-  if (!uridecodebin_ || !audiobin_) return;
-
-  GstPad* pad = gst_element_get_static_pad(uridecodebin_, "src");
-  if (!pad) return;
-
-  gst_object_unref(pad);
-  gst_element_link(uridecodebin_, audiobin_);
-}
-
 bool GstEnginePipeline::InitFromString(const QString& pipeline) {
-  pipeline_ = gst_pipeline_new("pipeline");
-
   GstElement* new_bin =
       CreateDecodeBinFromString(pipeline.toAscii().constData());
-  if (!new_bin) {
-    return false;
-  }
 
-  if (!ReplaceDecodeBin(new_bin)) return false;
-
-  if (!Init()) return false;
-  return gst_element_link(new_bin, audiobin_);
+  return InitDecodeBin(new_bin);
 }
 
 bool GstEnginePipeline::InitFromUrl(const QUrl& url, qint64 end_nanosec) {
-  pipeline_ = gst_pipeline_new("pipeline");
-
   if (url.scheme() == "cdda" && !url.path().isEmpty()) {
     // Currently, Gstreamer can't handle input CD devices inside cdda URL. So
     // we handle them ourselve: we extract the track number and re-create an
@@ -461,10 +418,27 @@ bool GstEnginePipeline::InitFromUrl(const QUrl& url, qint64 end_nanosec) {
   }
   end_offset_nanosec_ = end_nanosec;
 
-  // Decode bin
-  if (!ReplaceDecodeBin(url_)) return false;
+  if (url_.scheme() == "spotify") {
+    GstElement* new_bin = CreateSpotifyBin(url_);
+    return InitDecodeBin(new_bin);
+  }
+
+  pipeline_ = engine_->CreateElement("playbin");
+  g_object_set(G_OBJECT(pipeline_), "uri", url_.toEncoded().constData(),
+               nullptr);
+  CHECKED_GCONNECT(G_OBJECT(pipeline_), "about-to-finish",
+                   &AboutToFinishCallback, this);
+
+  CHECKED_GCONNECT(G_OBJECT(pipeline_), "pad-added", &NewPadCallback, this);
+  CHECKED_GCONNECT(G_OBJECT(pipeline_), "notify::source", &SourceSetupCallback,
+                   this);
 
-  return Init();
+  if (!InitAudioBin()) return false;
+
+  // Set playbin's sink to be our costum audio-sink.
+  g_object_set(GST_OBJECT(pipeline_), "audio-sink", audiobin_, NULL);
+  pipeline_is_connected_ = true;
+  return true;
 }
 
 GstEnginePipeline::~GstEnginePipeline() {
@@ -541,12 +515,7 @@ GstBusSyncReply GstEnginePipeline::BusCallbackSync(GstBus*, GstMessage* msg,
       break;
 
     case GST_MESSAGE_STREAM_START:
-      if (instance->emit_track_ended_on_stream_start_) {
-        qLog(Debug) << "New segment started, EOS will signal on next buffer "
-                       "discontinuity";
-        instance->emit_track_ended_on_stream_start_ = false;
-        instance->emit_track_ended_on_time_discontinuity_ = true;
-      }
+      instance->StreamStartMessageReceived();
       break;
 
     default:
@@ -570,6 +539,20 @@ void GstEnginePipeline::StreamStatusMessageReceived(GstMessage* msg) {
   }
 }
 
+void GstEnginePipeline::StreamStartMessageReceived() {
+  if (next_uri_set_) {
+    next_uri_set_ = false;
+
+    url_ = next_url_;
+    end_offset_nanosec_ = next_end_offset_nanosec_;
+    next_url_ = QUrl();
+    next_beginning_offset_nanosec_ = 0;
+    next_end_offset_nanosec_ = 0;
+
+    emit EndOfStreamReached(id(), true);
+  }
+}
+
 void GstEnginePipeline::TaskEnterCallback(GstTask*, GThread*, gpointer) {
 // Bump the priority of the thread only on OS X
 
@@ -674,6 +657,14 @@ void GstEnginePipeline::StateChangedMessageReceived(GstMessage* msg) {
   if (pipeline_is_initialised_ && new_state != GST_STATE_PAUSED &&
       new_state != GST_STATE_PLAYING) {
     pipeline_is_initialised_ = false;
+
+    if (next_uri_set_ && new_state == GST_STATE_READY) {
+      // Revert uri and go back to PLAY state again
+      next_uri_set_ = false;
+      g_object_set(G_OBJECT(pipeline_), "uri", url_.toEncoded().constData(),
+                   nullptr);
+      SetState(GST_STATE_PLAYING);
+    }
   }
 }
 
@@ -684,13 +675,6 @@ void GstEnginePipeline::BufferingMessageReceived(GstMessage* msg) {
     return;
   }
 
-  // If we are loading new next track, we don't have to pause the playback.
-  // The buffering is for the next track and not the current one.
-  if (emit_track_ended_on_stream_start_) {
-    qLog(Debug) << "Buffering next track";
-    return;
-  }
-
   int percent = 0;
   gst_message_parse_buffering(msg, &percent);
 
@@ -760,43 +744,28 @@ GstPadProbeReturn GstEnginePipeline::HandoffCallback(GstPad*,
     quint64 end_time = start_time + duration;
 
     if (end_time > instance->end_offset_nanosec_) {
-      if (instance->has_next_valid_url()) {
-        if (instance->next_url_ == instance->url_ &&
-            instance->next_beginning_offset_nanosec_ ==
-                instance->end_offset_nanosec_) {
-          // The "next" song is actually the next segment of this file - so
-          // cheat and keep on playing, but just tell the Engine we've moved on.
-          instance->end_offset_nanosec_ = instance->next_end_offset_nanosec_;
-          instance->next_url_ = QUrl();
-          instance->next_beginning_offset_nanosec_ = 0;
-          instance->next_end_offset_nanosec_ = 0;
-
-          // GstEngine will try to seek to the start of the new section, but
-          // we're already there so ignore it.
-          instance->ignore_next_seek_ = true;
-          emit instance->EndOfStreamReached(instance->id(), true);
-        } else {
-          // We have a next song but we can't cheat, so move to it normally.
-          instance->TransitionToNext();
-        }
+      if (instance->has_next_valid_url() &&
+          instance->next_url_ == instance->url_ &&
+          instance->next_beginning_offset_nanosec_ ==
+              instance->end_offset_nanosec_) {
+        // The "next" song is actually the next segment of this file - so
+        // cheat and keep on playing, but just tell the Engine we've moved on.
+        instance->end_offset_nanosec_ = instance->next_end_offset_nanosec_;
+        instance->next_url_ = QUrl();
+        instance->next_beginning_offset_nanosec_ = 0;
+        instance->next_end_offset_nanosec_ = 0;
+
+        // GstEngine will try to seek to the start of the new section, but
+        // we're already there so ignore it.
+        instance->ignore_next_seek_ = true;
+        emit instance->EndOfStreamReached(instance->id(), true);
       } else {
-        // There's no next song
+        // There's no next song or we can't keep on playing.
         emit instance->EndOfStreamReached(instance->id(), false);
       }
     }
   }
 
-  if (instance->emit_track_ended_on_time_discontinuity_) {
-    if (GST_BUFFER_FLAG_IS_SET(buf, GST_BUFFER_FLAG_DISCONT) ||
-        GST_BUFFER_OFFSET(buf) < instance->last_buffer_offset_) {
-      qLog(Debug) << "Buffer discontinuity - emitting EOS";
-      instance->emit_track_ended_on_time_discontinuity_ = false;
-      emit instance->EndOfStreamReached(instance->id(), true);
-    }
-  }
-
-  instance->last_buffer_offset_ = GST_BUFFER_OFFSET(buf);
-
   return GST_PAD_PROBE_OK;
 }
 
@@ -827,17 +796,28 @@ GstPadProbeReturn GstEnginePipeline::EventHandoffCallback(GstPad*,
   return GST_PAD_PROBE_OK;
 }
 
-void GstEnginePipeline::SourceDrainedCallback(GstURIDecodeBin* bin,
-                                              gpointer self) {
+void GstEnginePipeline::AboutToFinishCallback(GstPlayBin* bin, gpointer self) {
   GstEnginePipeline* instance = reinterpret_cast<GstEnginePipeline*>(self);
-
-  if (instance->has_next_valid_url()) {
-    instance->TransitionToNext();
+  if (instance->has_next_valid_url() && instance->url_.scheme() != "spotify") {
+    // Set the next uri. When the current song ends it will be played
+    // automatically and a STREAM_START message is send to the bus.
+    // When the next uri is not playable an error message is send when the
+    // pipeline goes to PLAY (or PAUSE) state or immediately if it is currently
+    // in PLAY state.
+    instance->next_uri_set_ = true;
+    g_object_set(G_OBJECT(instance->pipeline_), "uri",
+                 instance->next_url_.toEncoded().constData(), nullptr);
+    // If the pipeline is currently buffering we can stop that now.
+    if (instance->buffering_) {
+      instance->buffering_ = false;
+      emit instance->BufferingFinished();
+      instance->SetState(GST_STATE_PLAYING);
+    }
   }
 }
 
-void GstEnginePipeline::SourceSetupCallback(GstURIDecodeBin* bin,
-                                            GParamSpec* pspec, gpointer self) {
+void GstEnginePipeline::SourceSetupCallback(GstPlayBin* bin, GParamSpec* pspec,
+                                            gpointer self) {
   GstEnginePipeline* instance = reinterpret_cast<GstEnginePipeline*>(self);
   GstElement* element;
   g_object_get(bin, "source", &element, nullptr);
@@ -885,33 +865,6 @@ void GstEnginePipeline::SourceSetupCallback(GstURIDecodeBin* bin,
   }
 }
 
-void GstEnginePipeline::TransitionToNext() {
-  GstElement* old_decode_bin = uridecodebin_;
-
-  ignore_tags_ = true;
-
-  ReplaceDecodeBin(next_url_);
-  gst_element_set_state(uridecodebin_, GST_STATE_PLAYING);
-  MaybeLinkDecodeToAudio();
-
-  url_ = next_url_;
-  end_offset_nanosec_ = next_end_offset_nanosec_;
-  next_url_ = QUrl();
-  next_beginning_offset_nanosec_ = 0;
-  next_end_offset_nanosec_ = 0;
-
-  // This function gets called when the source has been drained, even if the
-  // song hasn't finished playing yet.  We'll get a new stream when it really
-  // does finish, so emit TrackEnded then.
-  emit_track_ended_on_stream_start_ = true;
-
-  // This has to happen *after* the gst_element_set_state on the new bin to
-  // fix an occasional race condition deadlock.
-  sElementDeleter->DeleteElementLater(old_decode_bin);
-
-  ignore_tags_ = false;
-}
-
 qint64 GstEnginePipeline::position() const {
   gint64 value = 0;
   gst_element_query_position(pipeline_, GST_FORMAT_TIME, &value);
@@ -941,21 +894,22 @@ GstState GstEnginePipeline::state() const {
 
 QFuture<GstStateChangeReturn> GstEnginePipeline::SetState(GstState state) {
   if (url_.scheme() == "spotify" && !buffering_) {
-      const GstState current_state = this->state();
+    const GstState current_state = this->state();
 
-      if (state == GST_STATE_PAUSED && current_state == GST_STATE_PLAYING) {
-        SpotifyService* spotify = InternetModel::Service<SpotifyService>();
+    if (state == GST_STATE_PAUSED && current_state == GST_STATE_PLAYING) {
+      SpotifyService* spotify = InternetModel::Service<SpotifyService>();
 
-        // Need to schedule this in the spotify service's thread
-        QMetaObject::invokeMethod(spotify, "SetPaused", Qt::QueuedConnection,
-                                  Q_ARG(bool, true));
-      } else if (state == GST_STATE_PLAYING && current_state == GST_STATE_PAUSED) {
-        SpotifyService* spotify = InternetModel::Service<SpotifyService>();
+      // Need to schedule this in the spotify service's thread
+      QMetaObject::invokeMethod(spotify, "SetPaused", Qt::QueuedConnection,
+                                Q_ARG(bool, true));
+    } else if (state == GST_STATE_PLAYING &&
+               current_state == GST_STATE_PAUSED) {
+      SpotifyService* spotify = InternetModel::Service<SpotifyService>();
 
-        // Need to schedule this in the spotify service's thread
-        QMetaObject::invokeMethod(spotify, "SetPaused", Qt::QueuedConnection,
-                                  Q_ARG(bool, false));
-      }
+      // Need to schedule this in the spotify service's thread
+      QMetaObject::invokeMethod(spotify, "SetPaused", Qt::QueuedConnection,
+                                Q_ARG(bool, false));
+    }
   }
   return ConcurrentRun::Run<GstStateChangeReturn, GstElement*, GstState>(
       &set_state_threadpool_, &gst_element_set_state, pipeline_, state);
@@ -983,6 +937,14 @@ bool GstEnginePipeline::Seek(qint64 nanosec) {
     return true;
   }
 
+  if (next_uri_set_) {
+    qDebug() << "MYTODO: gstenginepipeline.seek: seeking after Transition";
+
+    pending_seek_nanosec_ = nanosec;
+    SetState(GST_STATE_READY);
+    return true;
+  }
+
   pending_seek_nanosec_ = -1;
   return gst_element_seek_simple(pipeline_, GST_FORMAT_TIME,
                                  GST_SEEK_FLAG_FLUSH, nanosec);
diff --git a/src/engines/gstenginepipeline.h b/src/engines/gstenginepipeline.h
index 60bf70a..929b2a6 100644
--- a/src/engines/gstenginepipeline.h
+++ b/src/engines/gstenginepipeline.h
@@ -37,7 +37,7 @@ class GstEngine;
 class BufferConsumer;
 
 struct GstQueue;
-struct GstURIDecodeBin;
+struct GstPlayBin;
 
 class GstEnginePipeline : public QObject {
   Q_OBJECT
@@ -95,7 +95,6 @@ class GstEnginePipeline : public QObject {
   // Returns this pipeline's state. May return GST_STATE_NULL if the state check
   // timed out. The timeout value is a reasonable default.
   GstState state() const;
-  qint64 segment_start() const { return segment_start_; }
 
   // Don't allow the user to change the playback state (playing/paused) while
   // the pipeline is buffering.
@@ -132,8 +131,8 @@ class GstEnginePipeline : public QObject {
   static void NewPadCallback(GstElement*, GstPad*, gpointer);
   static GstPadProbeReturn HandoffCallback(GstPad*, GstPadProbeInfo*, gpointer);
   static GstPadProbeReturn EventHandoffCallback(GstPad*, GstPadProbeInfo*, gpointer);
-  static void SourceDrainedCallback(GstURIDecodeBin*, gpointer);
-  static void SourceSetupCallback(GstURIDecodeBin*, GParamSpec* pspec,
+  static void AboutToFinishCallback(GstPlayBin*, gpointer);
+  static void SourceSetupCallback(GstPlayBin*, GParamSpec* pspec,
                                   gpointer);
   static void TaskEnterCallback(GstTask*, GThread*, gpointer);
 
@@ -143,23 +142,18 @@ class GstEnginePipeline : public QObject {
   void StateChangedMessageReceived(GstMessage*);
   void BufferingMessageReceived(GstMessage*);
   void StreamStatusMessageReceived(GstMessage*);
+  void StreamStartMessageReceived();
 
   QString ParseTag(GstTagList* list, const char* tag) const;
 
-  bool Init();
+  bool InitDecodeBin(GstElement* new_bin);
+  bool InitAudioBin();
+  GstElement* CreateSpotifyBin(const QUrl& url);
   GstElement* CreateDecodeBinFromString(const char* pipeline);
 
   void UpdateVolume();
   void UpdateEqualizer();
   void UpdateStereoBalance();
-  bool ReplaceDecodeBin(GstElement* new_bin);
-  bool ReplaceDecodeBin(const QUrl& url);
-
-  void TransitionToNext();
-
-  // If the decodebin is special (ie. not really a uridecodebin) then it'll have
-  // a src pad immediately and we can link it after everything's created.
-  void MaybeLinkDecodeToAudio();
 
  private slots:
   void FaderTimelineFinished();
@@ -193,9 +187,6 @@ class GstEnginePipeline : public QObject {
   QMutex buffer_consumers_mutex_;
   qint64 segment_start_;
   bool segment_start_received_;
-  bool emit_track_ended_on_stream_start_;
-  bool emit_track_ended_on_time_discontinuity_;
-  qint64 last_buffer_offset_;
 
   // Equalizer
   bool eq_enabled_;
@@ -264,6 +255,9 @@ class GstEnginePipeline : public QObject {
   bool pipeline_is_connected_;
   qint64 pending_seek_nanosec_;
 
+  // Complete the transition to the next song when it starts playing
+  bool next_uri_set_;
+
   int volume_percent_;
   qreal volume_modifier_;
 
@@ -272,10 +266,8 @@ class GstEnginePipeline : public QObject {
   bool use_fudge_timer_;
 
   GstElement* pipeline_;
-
-  // Bins
-  // uridecodebin ! audiobin
-  GstElement* uridecodebin_;
+  // The audiobin is either linked with a decodebin or set as sink of the
+  // playbin pipeline.
   GstElement* audiobin_;
 
   // Elements in the audiobin.  See comments in Init()'s definition.
